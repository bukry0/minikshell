**  collect_grbg fonksiyonu her Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, ona verilen her malloc edilmiÅŸ pointerâ€™Ä± tek bir baÄŸlÄ± listeye (yani prompt->grbg_lst) ekler.

**Ã‡Ã¼nkÃ¼ shell gibi bÃ¼yÃ¼k bir projede birÃ§ok yerde malloc yapÄ±lÄ±r ve hepsini free etmek iÃ§in her birini takip etmek zordur.

Bu yÃ¼zden:

** Nerede malloc yapÄ±lÄ±rsa yapÄ±lsÄ±n,
** Hemen ardÄ±ndan collect_grbg(prompt, ptr); yazÄ±lÄ±r,
** BÃ¶ylece tek bir listeye eklenmiÅŸ olur.

- - INTERACTIVE - NONINTERACTIVE - -

**Interaktif	KullanÄ±cÄ±nÄ±n terminalde doÄŸrudan komut yazdÄ±ÄŸÄ± yer: minishell> prompt'u.
Non-Interaktif	Shell'in Ã§ocuk prosesleri Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ± yer. Yani ls, cat, echo gibi dÄ±ÅŸ komutlarÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± yer.

**Interaktif modda kullanÄ±cÄ±ya yeni satÄ±r aÃ§man, prompt'u temiz gÃ¶stermen gerekir.
Non-interaktif modda ise dÄ±ÅŸ komutlar Ctrl+C veya Ctrl+\ gibi sinyalleri kendi baÅŸÄ±na almalÄ±dÄ±r, yoksa dÃ¼zgÃ¼n bitmezler.

Promptâ€™ta bekleniyor  ->	signals_interactive()	->   Ctrl+C'ye temiz tepki ver, Ctrl+\â€™yÄ± yok say
Komut Ã§alÄ±ÅŸtÄ±rÄ±lÄ±yor (dÄ±ÅŸ proses).  ->  signals_non_interactive()  ->  Sinyaller dÄ±ÅŸ komuta geÃ§sin, bazen core dumped yazÄ±lsÄ±n

*TuÅŸ	    Sinyal	Ne yapar	        Kim etkilenir
*Ctrl+C	SIGINT	NazikÃ§e durdurur	Ã‡alÄ±ÅŸan child process
*Ctrl+\	SIGQUIT	SertÃ§e durdurur     mesaj	Ã‡alÄ±ÅŸan child process

- - INTERACTIVE MI NON-INTERACTIVE MI - - 

EÄŸer stdin gerÃ§ek bir terminale baÄŸlÄ±ysa, kullanÄ±cÄ±yla etkileÅŸimli (interaktif) moddasÄ±ndÄ±r.
EÄŸer stdin bir dosya, pipe, ya da baÅŸka bir ÅŸeyse, o zaman interaktif deÄŸildir.
isatty() fonksiyonu, dosya tanÄ±mlayÄ±cÄ±sÄ±nÄ±n bir terminal olup olmadÄ±ÄŸÄ±nÄ± dÃ¶ner.

??????kodda interaktif mÄ± noninteraktif mi olduÄŸunu anlayan yer


****** API (Application Programming Interface) Ne Demek?
API, bir programlama kÃ¼tÃ¼phanesinin diÄŸer programlar tarafÄ±ndan kullanÄ±labilmesi iÃ§in sunduÄŸu fonksiyon, yapÄ± ve sabitler topluluÄŸudur.
Yani readline kÃ¼tÃ¼phanesinin sunduÄŸu fonksiyonlarÄ± kullanarak kendi programÄ±nda komut satÄ±rÄ± arayÃ¼zÃ¼ yapabilirsin.

******DENEME*******
rl_bind_key
Readline iÃ§indeki bir fonksiyon.
AmaÃ§: Belirli bir tuÅŸa (Ã¶rneÄŸin tab tuÅŸuna) Ã¶zel bir iÅŸlem atamak.
Parametreleri:
Ä°lk parametre: tuÅŸun ASCII kodu (Ã¶rneÄŸin '\t' tab tuÅŸu)
Ä°kinci parametre: bu tuÅŸa basÄ±ldÄ±ÄŸÄ±nda Ã§alÄ±ÅŸacak fonksiyon.
rl_complete
Readlineâ€™Ä±n iÃ§inde bulunan ve otomatik tamamlama yapan fonksiyon.
Ã–rneÄŸin tab tuÅŸuna basÄ±ldÄ±ÄŸÄ±nda, readline bunu Ã§aÄŸÄ±rarak mevcut yazÄ±lan kelimeyi tamamlamaya Ã§alÄ±ÅŸÄ±r.


not: DÃ¼z gcc deneme.c komutu sadece derler, ama readline fonksiyonlarÄ±nÄ±n tanÄ±mlÄ± olduÄŸu .dylib/.so dosyalarÄ±nÄ± baÄŸlamaz.
Ã–zellikle MacOSâ€™ta ya da bazÄ± Linux daÄŸÄ±tÄ±mlarÄ±nda, readline kÃ¼tÃ¼phanesi baÅŸka kÃ¼tÃ¼phanelere baÄŸlÄ± olabilir (Ã¶rneÄŸin ncurses).

#include	readline.h ve history.h dosyalarÄ±
Derleme	gcc -c deneme.c â†’ Header dosyalarÄ± aranÄ±r
BaÄŸlama	-lreadline â†’ FonksiyonlarÄ± tanÄ±yan lib eklenir
Eksikse	undefined reference ya da undeclared function hatasÄ± olur

*******
readline() bir satÄ±rÄ±n tamamÄ±nÄ± okuyana kadar bekler.
Bu "satÄ±rÄ±n tamamÄ±" â†’ kullanÄ±cÄ± Enter tuÅŸuna bastÄ±ÄŸÄ±nda oluÅŸur.
Yani readline():
Arkaplanda stdinâ€™i okur (non-blocking deÄŸil).
GirdiÄŸi karakterleri bir buffer'da tutar.
Enter (\n veya ASCII 10) tuÅŸu gelene kadar bekler.
Enter geldiÄŸinde:
Bufferâ€™daki karakterleri char * olarak dÃ¶ner.

********
ğŸ”¹ Interaktif Shell Nedir?
KullanÄ±cÄ± ile etkileÅŸimli olarak Ã§alÄ±ÅŸan shellâ€™dir.
Yani terminal aÃ§Ä±k, kullanÄ±cÄ± komut yazÄ±yor, enterâ€™a basÄ±yor.
readline() gibi fonksiyonlarla input alÄ±nÄ±r.
ğŸ”¹ Non-Interaktif Shell Nedir?
Shell bir script Ã§alÄ±ÅŸtÄ±rÄ±yordur veya input'u pipeâ€™tan alÄ±yordur.
Yani kullanÄ±cÄ± doÄŸrudan terminalde komut girmiyor.
readline() kullanÄ±lmaz, get_next_line() gibi satÄ±r satÄ±r input okunur mesela.

signals_interactive()	KullanÄ±cÄ±dan readline ile input alÄ±nÄ±rken Ã§aÄŸrÄ±lÄ±r (gerÃ§ek interaktif mod).
signals_non_interactive()	Heredoc, child process, veya Ã¶zel durumlarda Ã§aÄŸrÄ±lÄ±r. Shell interaktif olsa da readline yokken kullanÄ±lÄ±r.
YENI ISIM ONERILERI: signals_for_readline() â†’ readline aktifken (interaktif)
signals_for_execution() â†’ komut Ã§alÄ±ÅŸtÄ±rÄ±lÄ±rken
signals_for_heredoc() â†’ heredoc sÄ±rasÄ±nda

**********
Durum	Girdiyi kim alÄ±yor	KullanÄ±cÄ± yazÄ±yor mu	readline var mÄ±
Normal prompt	readline()	Evet	âœ…
Heredoc	read() / gnl()	Evet	âŒ
Exec sÃ¼reci	execve() sonrasÄ±

**********
Normal komut satÄ±rÄ± giriÅŸlerinde kullanÄ±cÄ±dan veri almak iÃ§in readline kullanÄ±lÄ±r.
Ancak heredoc gibi Ã¶zel durumlarda, readline kullanmak teknik olarak zordur veya SIGINT
 (Ctrl+C) gibi sinyalleri dÃ¼zgÃ¼n iÅŸleyemez. Bu yÃ¼zden read ya da get_next_line gibi basit
  yÃ¶ntemlerle giriÅŸ alÄ±nÄ±r ve sinyal iÅŸlemesi (signals_non_interactive) ona gÃ¶re deÄŸiÅŸtirilir

********** Heredocâ€™ta beklenti ÅŸu:

Ctrl+C basÄ±lÄ±nca hemen heredoc kesilsin ve shellâ€™e dÃ¶nÃ¼lsÃ¼n.
Ama readline bu sinyali dÃ¼zgÃ¼n aktaramazsa:

Shell kilitlenmiÅŸ gibi gÃ¶rÃ¼nÃ¼r.
KullanÄ±cÄ± "iptal edemiyorum" diye delirir.

ğŸ’¾ 2. Heredoc neden geÃ§ici dosyaya yazar?

Ã‡Ã¼nkÃ¼ heredoc:

Bir komuta Ã§ok satÄ±rlÄ± bir input gÃ¶nderir.
cat << EOF
hello
world
EOF
Bu inputu cat'e nasÄ±l vereceksin? ÅÃ¶yle:

Bu satÄ±rlarÄ± bir yere yaz.
cat Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda bu satÄ±rlarÄ± okuyabileceÄŸi bir yerden oku.
ğŸ”§ Ã‡Ã¶zÃ¼m: geÃ§ici bir dosyaya yazÄ±lÄ±r
int tmp = open(".heredoc_tmp", O_WRONLY | O_CREAT | O_TRUNC, 0644);
write(tmp, "hello\n", ...);
write(tmp, "world\n", ...);
Sonra:

Bu dosya cat'e stdin olarak verilir (dup2 ile).
cat sanki EOF yazÄ±lana kadar bekleyen bir kullanÄ±cÄ±dan alÄ±yormuÅŸ gibi Ã§alÄ±ÅŸÄ±r.
ğŸ§¹ 3. Bu geÃ§ici dosya sonra silinir mi?

Evet, free() deÄŸil ama unlink() ile silinir.

unlink(".heredoc_tmp");
Ã‡Ã¼nkÃ¼ bu dosya artÄ±k lazÄ±m deÄŸildir. cat gibi komutlar zaten okumuÅŸtur.

Sen dÄ±ÅŸarÄ±dan sinyal handler kurmuÅŸ olsan bile, readline o sinyali:

ya yok sayar
ya kendi yÃ¶netir
ama sana vermez
ğŸ§© Bu yÃ¼zden heredoc'ta readline kullanÄ±lmaz:

Senin sinyale hemen tepki vermen gerek:

Ctrl+C â†’ heredoc iptal olsun, shellâ€™e dÃ¶nelim.
readline bunu engeller.
read() ise doÄŸrudan kesilir, sana sinyali bildirir.



add_history() nedir?

add_history() fonksiyonu GNU Readline kÃ¼tÃ¼phanesine ait bir fonksiyondur.
KullanÄ±cÄ±nÄ±n terminale yazdÄ±ÄŸÄ± komut satÄ±rÄ±nÄ± (string) history listesine ekler.
BÃ¶ylece kullanÄ±cÄ± Ã¶nceki komutlara ok tuÅŸlarÄ±yla eriÅŸebilir.
â€“ Sadece RAMâ€™e ekler.
â€“ Yani terminal aÃ§Ä±kken yukarÄ± okla (â†‘) eriÅŸebilirsin.
â€“ Shell kapanÄ±nca bu bilgiler kaybolur.
. write_history(".minishell_history");
â€“ RAMâ€™deki geÃ§miÅŸi .minishell_history adÄ±nda bir dosyaya yazar.
â€“ BÃ¶ylece shell yeniden aÃ§Ä±ldÄ±ÄŸÄ±nda geÃ§miÅŸ korunmuÅŸ olur.
 rl_clear_history(); ne yapar?
â€“ Sadece RAM'deki geÃ§miÅŸi siler, yani yukarÄ± okla gezilen liste sÄ±fÄ±rlanÄ±r.
â€“ EÄŸer .minishell_history dosyasÄ±na yazÄ±lmÄ±ÅŸsa, o dosyada hÃ¢lÃ¢ geÃ§miÅŸ durur.
// RAM'den sil
rl_clear_history();

// DosyayÄ± da silmek istersen:
remove(".minishell_history");
write_history("dosya_adÄ±") Ne Yapar?
Bu fonksiyon:
RAMâ€™de add_history() ile biriken tÃ¼m komut geÃ§miÅŸini,
Metin satÄ±rlarÄ± hÃ¢linde,
Verilen dosya yoluna yazar.
Sonraki Ã§alÄ±ÅŸtÄ±rmalarda bu dosyayÄ± geri yÃ¼klemek iÃ§in:
read_history(".minishell_history");
Bu da, dosyayÄ± okuyup history listesine RAM'de geri yÃ¼kler.

readline()	Prompt gÃ¶sterir, input alÄ±r
add_history()	AlÄ±nan input'u RAM'deki geÃ§miÅŸe ekler
write_history()	RAM'deki geÃ§miÅŸi dÃ¼z metin dosyasÄ±na yazar
read_history()	DÃ¼z metin dosyasÄ±ndan geÃ§miÅŸi RAM'e yÃ¼kler
clear_history()	RAM'deki geÃ§miÅŸi temizler
rl_clear_history()	AynÄ± iÅŸlev, daha teknik dÃ¼zeyde temizleme

Ne zaman Ã§aÄŸÄ±rÄ±lÄ±rlar?
read_history() â†’ Shell baÅŸlarken.
add_history() â†’ Her komut alÄ±ndÄ±ÄŸÄ±nda.
write_history() â†’ Shell kapanÄ±rken veya her komut sonrasÄ±.
clear_history() â†’ Shell tamamen sÄ±fÄ±rlanÄ±rken.

âœ… clear_history()
YÃ¼zeysel bir temizlik yapar.
add_history() ile eklenen satÄ±rlarÄ± temizler.
Readlineâ€™Ä±n dahili history linked list yapÄ±sÄ±ndaki verileri siler ama bazÄ± global stateâ€™leri bÄ±rakabilir.
âœ… rl_clear_history()
Daha derin bir temizlik yapar.
Sadece history verisini deÄŸil, readline iÃ§indeki ilgili tÃ¼m pointerâ€™larÄ±, bufferâ€™larÄ±, geÃ§ici bellekte tutulan verileri temizler.
Readlineâ€™Ä±n iÃ§ mantÄ±ÄŸÄ±nÄ± sÄ±fÄ±rlamaya daha yakÄ±ndÄ±r.
Sadece geÃ§miÅŸ satÄ±rlarÄ±nÄ± silmek istiyorsan	clear_history()
Shellâ€™i tamamen sÄ±fÄ±rlÄ±yorsan / exit Ã¶ncesi her ÅŸeyi temizlemek istiyorsan

prompt struct'Ä±nÄ±n kendisi, Ã§oÄŸu zaman Ã§Ã¶p listesine eklenmez, Ã§Ã¼nkÃ¼ prompt->grbg_lst henÃ¼z oluÅŸmadan Ã¶nce prompt zaten bellekte yaratÄ±lmÄ±ÅŸtÄ±r.

BoÅŸluk sayÄ±sÄ±nÄ± dÃ¼zeltmeden de komut iÅŸlenebilir, ama:
Orijinal shell davranÄ±ÅŸÄ±nÄ± taklit etmek iÃ§in (Ã¶rneÄŸin bash, zsh gibi),
Komut satÄ±rÄ±nÄ± daha temiz ve standart hale getirmek iÃ§in,
Parserâ€™Ä±n iÅŸleri kolaylaÅŸsÄ±n diye
Ã¶zel karakterlerin Ã¶ncesi ve sonrasÄ± boÅŸluklarla ayrÄ±lÄ±r.

Ä°fade	Ä°ÅŸlem SÄ±rasÄ±	SonuÃ§
(*new_str)[(*j)++]	new_str -> deref -> string -> j'inci karakter	Stringin j'inci karakteri
*new_str[(*j)++]	new_str[j] -> deref	new_str'in j'inci gÃ¶sterdiÄŸi stringin ilk karakteri

Ã‡ift operatÃ¶r baÅŸta (>>)	Evet, koyuyoruz
Tek operatÃ¶r baÅŸta (>)	HayÄ±r, koymuyoruz (ÅŸart var)


???READLINE READ FARKI????
 1. "input_string iÃ§in biz yer aÃ§madÄ±k" â€” Ama neden Ã§alÄ±ÅŸÄ±yor?
ğŸ¯ Ã‡Ã¼nkÃ¼ readline() senin yerine malloc() yapÄ±yor!
Yani sen ÅŸÃ¶yle yazÄ±yorsun ya:
prompt->input_string = readline("minishell> ");
AslÄ±nda bu satÄ±r ÅŸu 3 adÄ±mÄ± otomatik olarak yapÄ±yor:
Terminale minishell> prompt'unu yazÄ±yor.
KullanÄ±cÄ±dan input alÄ±yor.
YazÄ±lan inputu iÃ§eren bir char * bellekte malloc() ile ayÄ±rÄ±yor ve onu sana dÃ¶ndÃ¼rÃ¼yor.
Yani: readline() fonksiyonu sonucu olarak sana malloc() ile ayrÄ±lmÄ±ÅŸ bir string pointerÄ± dÃ¶ndÃ¼rÃ¼r.

ğŸ¯ interactive â†’ non-interactive geÃ§iÅŸinin sebebi ne?
Evet:
KullanÄ±cÄ± artÄ±k komutunu readline() ile yazdÄ± ve Enterâ€™a bastÄ±.
ArtÄ±k o giriÅŸ tamamlandÄ±, ÅŸimdi sÄ±ra o komutu iÅŸlemek, Ã§alÄ±ÅŸtÄ±rmak (Ã¶rneÄŸin fork + execve) vs.
Ä°ÅŸte bu andan itibaren:
Shell artÄ±k kullanÄ±cÄ±yla aktif yazÄ±ÅŸmÄ±yor,
Prompt gÃ¶sterilmiyor,
Readline kullanÄ±lmÄ±yor.
Yani:
ArtÄ±k interaktif input deÄŸil, iÅŸlem sÃ¼reci baÅŸladÄ±.
Bu yÃ¼zden signals_non_interactive() gibi bir ÅŸey yapÄ±lÄ±r.
ğŸ§  Peki bu geÃ§iÅŸin anlamÄ± sinyaller aÃ§Ä±sÄ±ndan ne?
Interaktif Modda:
Ctrl+C (SIGINT) â†’ sadece prompt'u siler, kullanÄ±cÄ±ya yeni satÄ±r verir.
Ctrl+\ (SIGQUIT) â†’ genellikle hiÃ§bir ÅŸey yapmaz, baskÄ±lanÄ±r.
Non-Interaktif Modda:
Ctrl+C (SIGINT) â†’ iÅŸlem Ã§alÄ±ÅŸÄ±rken (Ã¶rneÄŸin cat, sleep) â†’ Ã¶ldÃ¼rÃ¼r.
Ctrl+\ (SIGQUIT) â†’ iÅŸlem Ã§alÄ±ÅŸÄ±rken â†’ "Quit: 3" mesajÄ± basabilir, iÅŸlem sonlanÄ±r.
ğŸ“Œ Yani:
Interaktif modda sinyaller daha "yumuÅŸak" davranÄ±r.
Non-interaktif modda ise sinyaller klasik UNIX davranÄ±ÅŸÄ± ile iÅŸlem Ã¶ldÃ¼rÃ¼r.
ğŸ“Š AkÄ±ÅŸa BakalÄ±m:
AÅŸama	Mod	Sinyal Tepkisi
KullanÄ±cÄ± yazÄ±yor	Interaktif	Ctrl+C satÄ±rÄ± iptal eder
Komut iÅŸleniyor (exec, vs)	Non-Interaktif	Ctrl+C iÅŸlemi keser, Ctrl+\ core dump olabilir
Heredoc yazÄ±lÄ±yor	Non-Interaktif	Ctrl+C heredoc'u iptal eder, shell Ã§Ã¶kmemeli
Yeni readline baÅŸlÄ±yor	Interaktif	Prompt tekrar dÃ¶ner, sinyaller yumuÅŸar
âœ… SonuÃ§
Evet, interactive â†’ non-interactive geÃ§iÅŸi yapÄ±yoruz Ã§Ã¼nkÃ¼:
KullanÄ±cÄ± artÄ±k komutu verdi,
Shell artÄ±k "komutu Ã§alÄ±ÅŸtÄ±rma" (execution) evresine geÃ§ti,
Bu evrede sinyallerin anlamÄ± farklÄ± olmalÄ± (Ã¶rneÄŸin Ctrl+C artÄ±k bir sÃ¼reci Ã¶ldÃ¼rebilir).
Bu geÃ§iÅŸleri iyi yÃ¶netmek minishell gibi projelerde doÄŸru sinyal davranÄ±ÅŸÄ± vermek iÃ§in kritik bir adÄ±mdÄ±r.


2. Non-interactive modda sinyaller ve core dump durumu
Ctrl+C (SIGINT)
Genellikle SIGINT sinyali programÄ± aniden sonlandÄ±rÄ±r, ama core dump oluÅŸturmaz.
Ã‡Ã¼nkÃ¼ SIGINT programÄ± durdurmak iÃ§in kullanÄ±lÄ±r, ama sistem genelde core dump Ã¼retmez.
Ctrl+\ (SIGQUIT)
SIGQUIT sinyali geldiÄŸinde program sonlandÄ±rÄ±lÄ±r ve core dump oluÅŸturulur.
Bu yÃ¼zden Quit (core dumped) mesajÄ± Ã§Ä±kar.


Core dump (Ã§ekirdek dÃ¶kÃ¼mÃ¼), bir program ani olarak Ã§Ã¶ktÃ¼ÄŸÃ¼nde (crash) iÅŸletim sisteminin o programÄ±n bellek gÃ¶rÃ¼ntÃ¼sÃ¼nÃ¼ (dump) bir dosyaya kaydetmesidir.
Bu dosya genellikle core veya core.<pid> gibi isimlerle oluÅŸur.
Bellek gÃ¶rÃ¼ntÃ¼sÃ¼; programÄ±n o anda kullandÄ±ÄŸÄ± deÄŸiÅŸkenler, yÄ±ÄŸÄ±n (stack), kayÄ±tlar (registers) gibi bilgileri iÃ§erir.
ğŸ§© Niye olur?
Programda bellek hatasÄ± (Ã¶rneÄŸin null pointerâ€™a eriÅŸmek),
YanlÄ±ÅŸ bellek kullanÄ±mÄ±,
TanÄ±mlanmamÄ±ÅŸ davranÄ±ÅŸlar,
Ä°ÅŸletim sistemine gÃ¶re SIGQUIT sinyali ile sonlanma gibi durumlarda,
Program aniden â€œÃ§Ã¶kebilirâ€ ve core dump oluÅŸabilir.
ğŸ” Ne iÅŸe yarar?
ProgramcÄ±lar hata ayÄ±klama (debugging) iÃ§in core dump dosyasÄ±nÄ± kullanÄ±r.
Bu dosyayÄ± gdb gibi hata ayÄ±klayÄ±cÄ±larla aÃ§Ä±p, programÄ±n neden Ã§Ã¶ktÃ¼ÄŸÃ¼nÃ¼ analiz ederler.
Ã–rneÄŸin â€œhangi satÄ±rdaâ€, â€œhangi deÄŸiÅŸkenin deÄŸerindeâ€ hata olduÄŸunu gÃ¶rmek iÃ§in.
ğŸ’¬ Terminalde Mesaj
Terminalde ÅŸu mesaj Ã§Ä±kar:
Quit (core dumped)
Bu, programÄ±n SIGQUIT sinyaliyle Ã§Ã¶ktÃ¼ÄŸÃ¼nÃ¼ ve core dump dosyasÄ± oluÅŸturulduÄŸunu gÃ¶sterir.
âš ï¸ Ã–zet
Terim	AnlamÄ±
Core dump	Program Ã§Ã¶ktÃ¼ÄŸÃ¼nde sistemin oluÅŸturduÄŸu bellek gÃ¶rÃ¼ntÃ¼sÃ¼ dosyasÄ±
Core dumped	Program Ã§Ã¶ktÃ¼ ve core dump dosyasÄ± oluÅŸturuldu
AmaÃ§	Hata ayÄ±klama iÃ§in belleÄŸin o anki durumunu kaydetmek
