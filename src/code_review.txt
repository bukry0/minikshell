**  collect_grbg fonksiyonu her çağrıldığında, ona verilen her malloc edilmiş pointer’ı tek bir bağlı listeye (yani prompt->grbg_lst) ekler.

**Çünkü shell gibi büyük bir projede birçok yerde malloc yapılır ve hepsini free etmek için her birini takip etmek zordur.

Bu yüzden:

** Nerede malloc yapılırsa yapılsın,
** Hemen ardından collect_grbg(prompt, ptr); yazılır,
** Böylece tek bir listeye eklenmiş olur.

- - INTERACTIVE - NONINTERACTIVE - -

**Interaktif	Kullanıcının terminalde doğrudan komut yazdığı yer: minishell> prompt'u.
Non-Interaktif	Shell'in çocuk prosesleri çalıştırdığı yer. Yani ls, cat, echo gibi dış komutların çalıştığı yer.

**Interaktif modda kullanıcıya yeni satır açman, prompt'u temiz göstermen gerekir.
Non-interaktif modda ise dış komutlar Ctrl+C veya Ctrl+\ gibi sinyalleri kendi başına almalıdır, yoksa düzgün bitmezler.

Prompt’ta bekleniyor  ->	signals_interactive()	->   Ctrl+C'ye temiz tepki ver, Ctrl+\’yı yok say
Komut çalıştırılıyor (dış proses).  ->  signals_non_interactive()  ->  Sinyaller dış komuta geçsin, bazen core dumped yazılsın

*Tuş	    Sinyal	Ne yapar	        Kim etkilenir
*Ctrl+C	SIGINT	Nazikçe durdurur	Çalışan child process
*Ctrl+\	SIGQUIT	Sertçe durdurur     mesaj	Çalışan child process

- - INTERACTIVE MI NON-INTERACTIVE MI - - 

Eğer stdin gerçek bir terminale bağlıysa, kullanıcıyla etkileşimli (interaktif) moddasındır.
Eğer stdin bir dosya, pipe, ya da başka bir şeyse, o zaman interaktif değildir.
isatty() fonksiyonu, dosya tanımlayıcısının bir terminal olup olmadığını döner.

??????kodda interaktif mı noninteraktif mi olduğunu anlayan yer


****** API (Application Programming Interface) Ne Demek?
API, bir programlama kütüphanesinin diğer programlar tarafından kullanılabilmesi için sunduğu fonksiyon, yapı ve sabitler topluluğudur.
Yani readline kütüphanesinin sunduğu fonksiyonları kullanarak kendi programında komut satırı arayüzü yapabilirsin.

******DENEME*******
rl_bind_key
Readline içindeki bir fonksiyon.
Amaç: Belirli bir tuşa (örneğin tab tuşuna) özel bir işlem atamak.
Parametreleri:
İlk parametre: tuşun ASCII kodu (örneğin '\t' tab tuşu)
İkinci parametre: bu tuşa basıldığında çalışacak fonksiyon.
rl_complete
Readline’ın içinde bulunan ve otomatik tamamlama yapan fonksiyon.
Örneğin tab tuşuna basıldığında, readline bunu çağırarak mevcut yazılan kelimeyi tamamlamaya çalışır.


not: Düz gcc deneme.c komutu sadece derler, ama readline fonksiyonlarının tanımlı olduğu .dylib/.so dosyalarını bağlamaz.
Özellikle MacOS’ta ya da bazı Linux dağıtımlarında, readline kütüphanesi başka kütüphanelere bağlı olabilir (örneğin ncurses).

#include	readline.h ve history.h dosyaları
Derleme	gcc -c deneme.c → Header dosyaları aranır
Bağlama	-lreadline → Fonksiyonları tanıyan lib eklenir
Eksikse	undefined reference ya da undeclared function hatası olur

*******
readline() bir satırın tamamını okuyana kadar bekler.
Bu "satırın tamamı" → kullanıcı Enter tuşuna bastığında oluşur.
Yani readline():
Arkaplanda stdin’i okur (non-blocking değil).
Girdiği karakterleri bir buffer'da tutar.
Enter (\n veya ASCII 10) tuşu gelene kadar bekler.
Enter geldiğinde:
Buffer’daki karakterleri char * olarak döner.

********
🔹 Interaktif Shell Nedir?
Kullanıcı ile etkileşimli olarak çalışan shell’dir.
Yani terminal açık, kullanıcı komut yazıyor, enter’a basıyor.
readline() gibi fonksiyonlarla input alınır.
🔹 Non-Interaktif Shell Nedir?
Shell bir script çalıştırıyordur veya input'u pipe’tan alıyordur.
Yani kullanıcı doğrudan terminalde komut girmiyor.
readline() kullanılmaz, get_next_line() gibi satır satır input okunur mesela.

signals_interactive()	Kullanıcıdan readline ile input alınırken çağrılır (gerçek interaktif mod).
signals_non_interactive()	Heredoc, child process, veya özel durumlarda çağrılır. Shell interaktif olsa da readline yokken kullanılır.
YENI ISIM ONERILERI: signals_for_readline() → readline aktifken (interaktif)
signals_for_execution() → komut çalıştırılırken
signals_for_heredoc() → heredoc sırasında

**********
Durum	Girdiyi kim alıyor	Kullanıcı yazıyor mu	readline var mı
Normal prompt	readline()	Evet	✅
Heredoc	read() / gnl()	Evet	❌
Exec süreci	execve() sonrası

**********
Normal komut satırı girişlerinde kullanıcıdan veri almak için readline kullanılır.
Ancak heredoc gibi özel durumlarda, readline kullanmak teknik olarak zordur veya SIGINT
 (Ctrl+C) gibi sinyalleri düzgün işleyemez. Bu yüzden read ya da get_next_line gibi basit
  yöntemlerle giriş alınır ve sinyal işlemesi (signals_non_interactive) ona göre değiştirilir

********** Heredoc’ta beklenti şu:

Ctrl+C basılınca hemen heredoc kesilsin ve shell’e dönülsün.
Ama readline bu sinyali düzgün aktaramazsa:

Shell kilitlenmiş gibi görünür.
Kullanıcı "iptal edemiyorum" diye delirir.

💾 2. Heredoc neden geçici dosyaya yazar?

Çünkü heredoc:

Bir komuta çok satırlı bir input gönderir.
cat << EOF
hello
world
EOF
Bu inputu cat'e nasıl vereceksin? Şöyle:

Bu satırları bir yere yaz.
cat çalıştığında bu satırları okuyabileceği bir yerden oku.
🔧 Çözüm: geçici bir dosyaya yazılır
int tmp = open(".heredoc_tmp", O_WRONLY | O_CREAT | O_TRUNC, 0644);
write(tmp, "hello\n", ...);
write(tmp, "world\n", ...);
Sonra:

Bu dosya cat'e stdin olarak verilir (dup2 ile).
cat sanki EOF yazılana kadar bekleyen bir kullanıcıdan alıyormuş gibi çalışır.
🧹 3. Bu geçici dosya sonra silinir mi?

Evet, free() değil ama unlink() ile silinir.

unlink(".heredoc_tmp");
Çünkü bu dosya artık lazım değildir. cat gibi komutlar zaten okumuştur.

Sen dışarıdan sinyal handler kurmuş olsan bile, readline o sinyali:

ya yok sayar
ya kendi yönetir
ama sana vermez
🧩 Bu yüzden heredoc'ta readline kullanılmaz:

Senin sinyale hemen tepki vermen gerek:

Ctrl+C → heredoc iptal olsun, shell’e dönelim.
readline bunu engeller.
read() ise doğrudan kesilir, sana sinyali bildirir.



add_history() nedir?

add_history() fonksiyonu GNU Readline kütüphanesine ait bir fonksiyondur.
Kullanıcının terminale yazdığı komut satırını (string) history listesine ekler.
Böylece kullanıcı önceki komutlara ok tuşlarıyla erişebilir.
– Sadece RAM’e ekler.
– Yani terminal açıkken yukarı okla (↑) erişebilirsin.
– Shell kapanınca bu bilgiler kaybolur.
. write_history(".minishell_history");
– RAM’deki geçmişi .minishell_history adında bir dosyaya yazar.
– Böylece shell yeniden açıldığında geçmiş korunmuş olur.
 rl_clear_history(); ne yapar?
– Sadece RAM'deki geçmişi siler, yani yukarı okla gezilen liste sıfırlanır.
– Eğer .minishell_history dosyasına yazılmışsa, o dosyada hâlâ geçmiş durur.
// RAM'den sil
rl_clear_history();

// Dosyayı da silmek istersen:
remove(".minishell_history");
write_history("dosya_adı") Ne Yapar?
Bu fonksiyon:
RAM’de add_history() ile biriken tüm komut geçmişini,
Metin satırları hâlinde,
Verilen dosya yoluna yazar.
Sonraki çalıştırmalarda bu dosyayı geri yüklemek için:
read_history(".minishell_history");
Bu da, dosyayı okuyup history listesine RAM'de geri yükler.

readline()	Prompt gösterir, input alır
add_history()	Alınan input'u RAM'deki geçmişe ekler
write_history()	RAM'deki geçmişi düz metin dosyasına yazar
read_history()	Düz metin dosyasından geçmişi RAM'e yükler
clear_history()	RAM'deki geçmişi temizler
rl_clear_history()	Aynı işlev, daha teknik düzeyde temizleme

Ne zaman çağırılırlar?
read_history() → Shell başlarken.
add_history() → Her komut alındığında.
write_history() → Shell kapanırken veya her komut sonrası.
clear_history() → Shell tamamen sıfırlanırken.

✅ clear_history()
Yüzeysel bir temizlik yapar.
add_history() ile eklenen satırları temizler.
Readline’ın dahili history linked list yapısındaki verileri siler ama bazı global state’leri bırakabilir.
✅ rl_clear_history()
Daha derin bir temizlik yapar.
Sadece history verisini değil, readline içindeki ilgili tüm pointer’ları, buffer’ları, geçici bellekte tutulan verileri temizler.
Readline’ın iç mantığını sıfırlamaya daha yakındır.
Sadece geçmiş satırlarını silmek istiyorsan	clear_history()
Shell’i tamamen sıfırlıyorsan / exit öncesi her şeyi temizlemek istiyorsan

prompt struct'ının kendisi, çoğu zaman çöp listesine eklenmez, çünkü prompt->grbg_lst henüz oluşmadan önce prompt zaten bellekte yaratılmıştır.

Boşluk sayısını düzeltmeden de komut işlenebilir, ama:
Orijinal shell davranışını taklit etmek için (örneğin bash, zsh gibi),
Komut satırını daha temiz ve standart hale getirmek için,
Parser’ın işleri kolaylaşsın diye
özel karakterlerin öncesi ve sonrası boşluklarla ayrılır.

İfade	İşlem Sırası	Sonuç
(*new_str)[(*j)++]	new_str -> deref -> string -> j'inci karakter	Stringin j'inci karakteri
*new_str[(*j)++]	new_str[j] -> deref	new_str'in j'inci gösterdiği stringin ilk karakteri

Çift operatör başta (>>)	Evet, koyuyoruz
Tek operatör başta (>)	Hayır, koymuyoruz (şart var)


???READLINE READ FARKI????
 1. "input_string için biz yer açmadık" — Ama neden çalışıyor?
🎯 Çünkü readline() senin yerine malloc() yapıyor!
Yani sen şöyle yazıyorsun ya:
prompt->input_string = readline("minishell> ");
Aslında bu satır şu 3 adımı otomatik olarak yapıyor:
Terminale minishell> prompt'unu yazıyor.
Kullanıcıdan input alıyor.
Yazılan inputu içeren bir char * bellekte malloc() ile ayırıyor ve onu sana döndürüyor.
Yani: readline() fonksiyonu sonucu olarak sana malloc() ile ayrılmış bir string pointerı döndürür.

🎯 interactive → non-interactive geçişinin sebebi ne?
Evet:
Kullanıcı artık komutunu readline() ile yazdı ve Enter’a bastı.
Artık o giriş tamamlandı, şimdi sıra o komutu işlemek, çalıştırmak (örneğin fork + execve) vs.
İşte bu andan itibaren:
Shell artık kullanıcıyla aktif yazışmıyor,
Prompt gösterilmiyor,
Readline kullanılmıyor.
Yani:
Artık interaktif input değil, işlem süreci başladı.
Bu yüzden signals_non_interactive() gibi bir şey yapılır.
🧠 Peki bu geçişin anlamı sinyaller açısından ne?
Interaktif Modda:
Ctrl+C (SIGINT) → sadece prompt'u siler, kullanıcıya yeni satır verir.
Ctrl+\ (SIGQUIT) → genellikle hiçbir şey yapmaz, baskılanır.
Non-Interaktif Modda:
Ctrl+C (SIGINT) → işlem çalışırken (örneğin cat, sleep) → öldürür.
Ctrl+\ (SIGQUIT) → işlem çalışırken → "Quit: 3" mesajı basabilir, işlem sonlanır.
📌 Yani:
Interaktif modda sinyaller daha "yumuşak" davranır.
Non-interaktif modda ise sinyaller klasik UNIX davranışı ile işlem öldürür.
📊 Akışa Bakalım:
Aşama	Mod	Sinyal Tepkisi
Kullanıcı yazıyor	Interaktif	Ctrl+C satırı iptal eder
Komut işleniyor (exec, vs)	Non-Interaktif	Ctrl+C işlemi keser, Ctrl+\ core dump olabilir
Heredoc yazılıyor	Non-Interaktif	Ctrl+C heredoc'u iptal eder, shell çökmemeli
Yeni readline başlıyor	Interaktif	Prompt tekrar döner, sinyaller yumuşar
✅ Sonuç
Evet, interactive → non-interactive geçişi yapıyoruz çünkü:
Kullanıcı artık komutu verdi,
Shell artık "komutu çalıştırma" (execution) evresine geçti,
Bu evrede sinyallerin anlamı farklı olmalı (örneğin Ctrl+C artık bir süreci öldürebilir).
Bu geçişleri iyi yönetmek minishell gibi projelerde doğru sinyal davranışı vermek için kritik bir adımdır.


2. Non-interactive modda sinyaller ve core dump durumu
Ctrl+C (SIGINT)
Genellikle SIGINT sinyali programı aniden sonlandırır, ama core dump oluşturmaz.
Çünkü SIGINT programı durdurmak için kullanılır, ama sistem genelde core dump üretmez.
Ctrl+\ (SIGQUIT)
SIGQUIT sinyali geldiğinde program sonlandırılır ve core dump oluşturulur.
Bu yüzden Quit (core dumped) mesajı çıkar.


Core dump (çekirdek dökümü), bir program ani olarak çöktüğünde (crash) işletim sisteminin o programın bellek görüntüsünü (dump) bir dosyaya kaydetmesidir.
Bu dosya genellikle core veya core.<pid> gibi isimlerle oluşur.
Bellek görüntüsü; programın o anda kullandığı değişkenler, yığın (stack), kayıtlar (registers) gibi bilgileri içerir.
🧩 Niye olur?
Programda bellek hatası (örneğin null pointer’a erişmek),
Yanlış bellek kullanımı,
Tanımlanmamış davranışlar,
İşletim sistemine göre SIGQUIT sinyali ile sonlanma gibi durumlarda,
Program aniden “çökebilir” ve core dump oluşabilir.
🔎 Ne işe yarar?
Programcılar hata ayıklama (debugging) için core dump dosyasını kullanır.
Bu dosyayı gdb gibi hata ayıklayıcılarla açıp, programın neden çöktüğünü analiz ederler.
Örneğin “hangi satırda”, “hangi değişkenin değerinde” hata olduğunu görmek için.
💬 Terminalde Mesaj
Terminalde şu mesaj çıkar:
Quit (core dumped)
Bu, programın SIGQUIT sinyaliyle çöktüğünü ve core dump dosyası oluşturulduğunu gösterir.
⚠️ Özet
Terim	Anlamı
Core dump	Program çöktüğünde sistemin oluşturduğu bellek görüntüsü dosyası
Core dumped	Program çöktü ve core dump dosyası oluşturuldu
Amaç	Hata ayıklama için belleğin o anki durumunu kaydetmek
